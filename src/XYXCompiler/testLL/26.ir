func build $start $ending {
%Start BB:
	$i = move 1
	jump %ForCond3

%ForCond3:
	$V282 = sle $i 49
	br $V282 %ForBody3 %ForAfter3

%ForBody3:
	$j = move 50
	jump %ForCond4

%ForCond4:
	$V193 = sub 98 $i
	$V194 = add $V193 1
	$V283 = sle $j $V194
	br $V283 %ForBody4 %ForAfter4

%ForBody4:
	$V196 = mul $i 8
	$V196 = add $c $V196
	$V195 = load 8 $V196 0
	$V197 = mul $j 8
	$V197 = add $V195 $V197
	store 8 $V197 1 0
	jump %ForUpdate4

%ForUpdate4:
	$backup = move $j
	$j = add $j 1
	jump %ForCond4

%ForAfter4:
	jump %ForUpdate3

%ForUpdate3:
	$backup = move $i
	$i = add $i 1
	jump %ForCond3

%ForAfter3:
	$i = move 1
	jump %ForCond5

%ForCond5:
	$V284 = sle $i 49
	br $V284 %ForBody5 %ForAfter5

%ForBody5:
	$V204 = mul $start 8
	$V204 = add $c $V204
	$V203 = load 8 $V204 0
	$V205 = mul $i 8
	$V205 = add $V203 $V205
	store 8 $V205 1 0
	jump %ForUpdate5

%ForUpdate5:
	$backup = move $i
	$i = add $i 1
	jump %ForCond5

%ForAfter5:
	$i = move 50
	jump %ForCond6

%ForCond6:
	$V285 = sle $i 98
	br $V285 %ForBody6 %ForAfter6

%ForBody6:
	$V210 = mul $i 8
	$V210 = add $c $V210
	$V209 = load 8 $V210 0
	$V211 = mul $ending 8
	$V211 = add $V209 $V211
	store 8 $V211 1 0
	jump %ForUpdate6

%ForUpdate6:
	$backup = move $i
	$i = add $i 1
	jump %ForCond6

%ForAfter6:
	ret 0

}
func find $ending $start $flag {
%Start BB:
	$open = move 0
	$closed = move 1
	$i = move 1
	jump %ForCond7

%ForCond7:
	$V286 = sle $i $ending
	br $V286 %ForBody7 %ForAfter7

%ForBody7:
	$V218 = mul $i 8
	$V218 = add $visit $V218
	store 8 $V218 0 0
	jump %ForUpdate7

%ForUpdate7:
	$backup = move $i
	$i = add $i 1
	jump %ForCond7

%ForAfter7:
	store 8 $f $start 8
	$V221 = mul $start 8
	$V221 = add $visit $V221
	store 8 $V221 1 0
	$V222 = mul $start 8
	$V222 = add $pre $V222
	store 8 $V222 0 0
	$flag = move 0
	jump %WhileCond8

%WhileCond8:
	$V287 = slt $open $closed
	br $V287 %[&&]Lhs_IfTrue31 %WhileAfter8

%[&&]Lhs_IfTrue31:
	$V288 = seq $flag 0
	br $V288 %WhileBody8 %WhileAfter8

%WhileBody8:
	$backup = move $open
	$open = add $open 1
	$V228 = mul $open 8
	$V228 = add $f $V228
	$V227 = load 8 $V228 0
	$i = move $V227
	$j = move 1
	jump %ForCond9

%ForCond9:
	$V289 = sle $j $ending
	br $V289 %ForBody9 %ForAfter9

%ForBody9:
	$V232 = mul $i 8
	$V232 = add $c $V232
	$V231 = load 8 $V232 0
	$V234 = mul $j 8
	$V234 = add $V231 $V234
	$V233 = load 8 $V234 0
	$V290 = sgt $V233 0
	br $V290 %[&&]Lhs_IfTrue38 %AfterIF37

%[&&]Lhs_IfTrue38:
	$V237 = mul $j 8
	$V237 = add $visit $V237
	$V236 = load 8 $V237 0
	$V291 = seq $V236 0
	br $V291 %ThenBody36 %AfterIF37

%ThenBody36:
	$V238 = mul $j 8
	$V238 = add $visit $V238
	store 8 $V238 1 0
	$backup = move $closed
	$closed = add $closed 1
	$V241 = mul $closed 8
	$V241 = add $f $V241
	store 8 $V241 $j 0
	$V242 = mul $j 8
	$V242 = add $pre $V242
	store 8 $V242 $i 0
	$V292 = seq $closed $ending
	br $V292 %ThenBody39 %AfterIF40

%ThenBody39:
	$flag = move 1
	jump %AfterIF40

%AfterIF40:

%AfterIF37:
	jump %ForUpdate9

%ForUpdate9:
	$backup = move $j
	$j = add $j 1
	jump %ForCond9

%ForAfter9:

%WhileAfter8:
	ret $flag

}
func improve $ending {
%Start BB:
	$i = move $ending
	$backup = move $ans
	$ans = add $ans 1
	jump %WhileCond10

%WhileCond10:
	$V251 = mul $i 8
	$V251 = add $pre $V251
	$V250 = load 8 $V251 0
	$V293 = sgt $V250 0
	br $V293 %WhileBody10 %WhileAfter10

%WhileBody10:
	$V253 = mul $i 8
	$V253 = add $pre $V253
	$V252 = load 8 $V253 0
	$j = move $V252
	$V255 = mul $j 8
	$V255 = add $c $V255
	$V254 = load 8 $V255 0
	$V256 = mul $i 8
	$V256 = add $V254 $V256
	$V258 = mul $j 8
	$V258 = add $c $V258
	$V257 = load 8 $V258 0
	$V260 = mul $i 8
	$V260 = add $V257 $V260
	$V259 = load 8 $V260 0
	$backup = move $V259
	$V259 = sub $V259 1
	$V264 = mul $i 8
	$V264 = add $c $V264
	$V263 = load 8 $V264 0
	$V265 = mul $j 8
	$V265 = add $V263 $V265
	$V267 = mul $i 8
	$V267 = add $c $V267
	$V266 = load 8 $V267 0
	$V269 = mul $j 8
	$V269 = add $V266 $V269
	$V268 = load 8 $V269 0
	$backup = move $V268
	$V268 = add $V268 1
	$i = move $j
	jump %WhileCond10

%WhileAfter10:
	ret 0

}
void origin $N {
%Start BB:
	$new = mul $N 8
	$new = alloc $new
	$c = move $new
	$i = move 0
	jump %ForCond1

%ForCond1:
	$V294 = slt $i $N
	br $V294 %ForBody1 %ForAfter1

%ForBody1:
	$V179 = mul $i 8
	$V179 = add $c $V179
	$new = mul $N 8
	$new = alloc $new
	store 8 $V179 $new 0
	$j = move 0
	jump %ForCond2

%ForCond2:
	$V295 = slt $j $N
	br $V295 %ForBody2 %ForAfter2

%ForBody2:
	$V183 = mul $i 8
	$V183 = add $c $V183
	$V182 = load 8 $V183 0
	$V184 = mul $j 8
	$V184 = add $V182 $V184
	store 8 $V184 0 0
	jump %ForUpdate2

%ForUpdate2:
	$backup = move $j
	$j = add $j 1
	jump %ForCond2

%ForAfter2:
	jump %ForUpdate1

%ForUpdate1:
	$backup = move $i
	$i = add $i 1
	jump %ForCond1

%ForAfter1:
	ret 0

}
func main {
%Entry:
	$ans = move 0
	$new = alloc 880
	$visit = move $new
	$new = alloc 880
	$pre = move $new
	$new = alloc 880
	$f = move $new
	call origin 110 
	$k = move 0
	$start = move 0
	$ending = move 0
	$flag = move 0
	$i1 = move 0
	$k = move 0
	$start = move 99
	$ending = move 100
	$flag = move 0
	$buildret = call build $start $ending 
	jump %WhileCond11

%WhileCond11:
	$findret = call find $ending $start $flag 
	$V296 = sgt $findret 0
	br $V296 %WhileBody11 %WhileAfter11

%WhileBody11:
	$improveret = call improve $ending 
	jump %WhileCond11

%WhileAfter11:
	ret $ans

}
